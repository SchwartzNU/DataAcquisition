classdef AutoCenter < StageProtocol
    
    properties (Constant)
        identifier = 'edu.northwestern.SchwartzLab.AutoCenter'
        version = 1
        displayName = 'Auto Center'
    end
    
    properties
        amp
        %times in ms
        preTime = 250 %will be rounded to account for frame rate
        tailTime = 250 %will be rounded to account for frame rate
        stimTime = 500
        
        %in microns, use rigConfig to set microns per pixel
        spotDiameter = 50;
        finalResolution = 20;
        initialSearchRadius = 200;
        numAttempts = 30;
        searchCirclePoints = 3;
        potentialBestCount = 2;

        intensity = 1.0;
        startX = 0;
        startY = 0;
%         maxPosition = 200;
    end
   
    properties
       %interpulse interval in s
       interpulseInterval = 0;
    end

        
    properties (Hidden)
       spatialFigure
       curPositionX;
       curPositionY;
       positions;
       nextPositions;
       foundCenter;
       currentSearchRadius;
    end
    
    methods
        
        function p = parameterProperty(obj, parameterName)
            % Call the base method to create the property object.
            p = parameterProperty@StageProtocol(obj, parameterName);
            
            % Return properties for the specified parameter (see ParameterProperty class).
            switch parameterName
                case 'interpulseInterval'
                    p.units = 's';
                case {'startX', 'startY', 'spotDiameter','maxPosition'}
                    p.units = 'um';
                    p.displayTab = 'mostUsed';
                case 'numAttempts'
                    p.displayTab = 'mostUsed';
                case {'intensity', 'meanLevel'}
                    p.displayTab = 'mostUsed';
                    p.units = 'rel';
            end
        end
        

        function prepareRun(obj)
            global DEMO_MODE;
            % Call the base method.
            prepareRun@StageProtocol(obj);
            
            %set directions
            obj.positions = zeros(obj.numAttempts, 2);
            obj.nextPositions = [];
            obj.foundCenter = 0;
            obj.currentSearchRadius = obj.initialSearchRadius;
            
            obj.spatialFigure = obj.openFigure('Spatial Response', obj.amp, 'StartTime', obj.stimStart, 'EndTime', obj.stimEnd,...
                'SpikeDetectorMode', obj.spikeDetection, 'SpikeThreshold', obj.spikeThreshold);
        
        end
        
        function prepareEpoch(obj, epoch)
            % Call the base method.
            prepareEpoch@StageProtocol(obj, epoch);
            [~,I] = max(obj.spatialFigure.responseValues);
            center = obj.spatialFigure.positions(I,:)

            if isempty(obj.nextPositions)

                %get the previous results and choose next points to search
                %around
                if length(obj.spatialFigure.positions) > 1
                    [~, indices] = sort(obj.spatialFigure.responseValues,'descend');
                    for i = 1:obj.potentialBestCount
                        bestPositions = obj.spatialFigure.positions(indices(i),:);
                    end
                else
                    bestPositions = [obj.startX,obj.startY];
                end
                
                searches = [0,0]; % include a recheck of the max point
                offset = random('unif', 0, 2*pi);
                for i=1:obj.searchCirclePoints
                    searches(1+i,:) = [cos(offset + i*2*pi/obj.searchCirclePoints),sin(offset + i*2*pi/obj.searchCirclePoints)];
                end
                
                for pos=1:size(bestPositions, 1)
                    for i=randperm(obj.searchCirclePoints + 1)
                        potentialNext = bestPositions(pos,:) + obj.currentSearchRadius * searches(i,:);

%                         if isempty(obj.spatialFigure.positions) || ...
%                                 ~ismember(potentialNext, obj.spatialFigure.positions, 'rows')
                        obj.nextPositions(size(obj.nextPositions,1)+1,:) = potentialNext;
%                         end
                    end
                end
                
                % refine by making jumps larger to start
%                 if obj.jumpMultiplier > 1
%                     obj.jumpMultiplier = obj.jumpMultiplier - 1;
%                 end
                
                obj.currentSearchRadius = mean([obj.finalResolution, obj.currentSearchRadius]);
            end
            
            if (obj.numEpochsCompleted == obj.numAttempts) || isempty(obj.nextPositions)
                obj.foundCenter = 1;
                'center found'
                [~,I] = max(obj.spatialFigure.responseValues);
                center = obj.spatialFigure.positions(I,:)
                obj.nextPositions(1,:) = bestPositions + [1,1];
            end
            
            obj.curPositionX = obj.nextPositions(1,1);
            obj.curPositionY = obj.nextPositions(1,2);
            obj.nextPositions = obj.nextPositions(2:end,:);
            obj.positions(obj.numEpochsQueued+1,:) = [obj.curPositionX, obj.curPositionY];
            epoch.addParameter('positionX', obj.curPositionX);
            epoch.addParameter('positionY', obj.curPositionY);
        end
        
        function preparePresentation(obj, presentation)
            %set bg
            obj.setBackground(presentation);
            
            circ = Ellipse();
            circ.color = obj.intensity;
            circ.radiusX = round(obj.spotDiameter/2/obj.rigConfig.micronsPerPixel);
            circ.radiusY = circ.radiusX;
            X = obj.curPositionX/obj.rigConfig.micronsPerPixel + obj.windowSize(1)/2;
            Y = obj.curPositionY/obj.rigConfig.micronsPerPixel + obj.windowSize(2)/2;
            circ.position = [X,Y];
            presentation.addStimulus(circ);
            
            function c = onDuringStim(state, preTime, stimTime, intensity, meanLevel)
                if state.time>preTime*1e-3 && state.time<=(preTime+stimTime)*1e-3
                    c = intensity;
                else
                    c = meanLevel;
                end
            end
            
            controller = PropertyController(circ, 'color', @(s)onDuringStim(s, obj.preTime, obj.stimTime, obj.intensity, obj.meanLevel));
            presentation.addController(controller);
            
            preparePresentation@StageProtocol(obj, presentation);
        end
        
       function queueEpoch(obj, epoch)            
            % Call the base method to queue the actual epoch.
            queueEpoch@StageProtocol(obj, epoch);
            
            % Queue the inter-pulse interval after queuing the epoch.
            if obj.interpulseInterval > 0
                obj.queueInterval(obj.interpulseInterval);
            end
        end
        
        
        function keepQueuing = continueQueuing(obj)
            % Check the base class method to make sure the user hasn't paused or stopped the protocol.
            keepQueuing = continueQueuing@StageProtocol(obj);
            
            % Keep queuing until the requested number of averages have been queued.
            if keepQueuing
                keepQueuing = ~obj.foundCenter && obj.numEpochsQueued < obj.numAttempts;
            end
        end
                
        function keepGoing = continueRun(obj)
            % Check the base class method to make sure the user hasn't paused or stopped the protocol.
            keepGoing = continueRun@StageProtocol(obj);
            
            % Keep going until the requested number of averages have been completed.
            if keepGoing
                keepGoing = ~obj.foundCenter && obj.numEpochsCompleted < obj.numAttempts;
            end
        end
        
        function pn = parameterNames(obj, includeConstant)
            if nargin == 1
                pn = parameterNames@StageProtocol(obj);
            else
                pn = parameterNames@StageProtocol(obj, includeConstant);
            end
            
            % hide params
            pn = pn(~strcmp(pn, 'preTime'));
            pn = pn(~strcmp(pn, 'tailTime'));
            
        end

    end
    
end